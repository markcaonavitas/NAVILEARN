<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>Speedometer HTML5 Canvas</title>
    <script>document.write('<script src="http://' + (location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1"></' + 'script>')</script>

    <script>
        /*jslint plusplus: true, sloppy: true, indent: 4 */
        (function () {
            "use strict";
            // this function is strict...
        }());

        var iCurrentSpeed = 0,
        iTargetSpeed = 0,
        bDecrement = null,
        job = null;

        function degToRad(angle) {
            // Degrees to radians
            return ((angle * Math.PI) / 180);
        }

        function radToDeg(angle) {
            // Radians to degree
            return ((angle * 180) / Math.PI);
        }


        function drawLine(options, line) {
            // Draw a line using the line object passed in
            options.ctx.beginPath();

            // Set attributes of open
            options.ctx.globalAlpha = line.alpha;
            options.ctx.lineWidth = line.lineWidth;
            options.ctx.fillStyle = line.fillStyle;
            options.ctx.strokeStyle = line.fillStyle;
            options.ctx.moveTo(line.from.X,
                line.from.Y);

            // Plot the line
            options.ctx.lineTo(
                line.to.X,
                line.to.Y
                );

            options.ctx.stroke();
        }

        function drawTriangle(options, triangle, ) {
            // Draw a triangle using the triangle object passed in
            options.ctx.beginPath();

            // Set attributes of open
            options.ctx.globalAlpha = triangle.alpha;
            options.ctx.lineWidth = triangle.lineWidth;
            options.ctx.fillStyle = triangle.fillStyle;
            options.ctx.strokeStyle = triangle.fillStyle;
            options.ctx.moveTo(triangle.from.X1, triangle.from.Y1);

            // Plot the triangle
            options.ctx.lineTo(triangle.to.X, triangle.to.Y);
            options.ctx.lineTo(triangle.from.X2, triangle.from.Y2);
            options.ctx.closePath();

            // the outline
            options.ctx.lineWidth = 1;
            options.ctx.strokeStyle = '#FFFFFF';
            options.ctx.stroke();

            // the fill color
            options.ctx.fillStyle = triangle.fillStyle;
            options.ctx.fill();
}

        function createLine(fromX, fromY, toX, toY, fillStyle, lineWidth, alpha) {
            // Create a line object using Javascript object notation
            return {
                from: {
                    X: fromX,
                    Y: fromY
                },
                to: {
                    X: toX,
                    Y: toY
                },
                fillStyle: fillStyle,
                lineWidth: lineWidth,
                alpha: alpha
            };
        }

        function createTriangle(fromX1, fromY1, fromX2, fromY2, toX, toY, fillStyle, lineWidth, alpha) {
            // Create a line object using Javascript object notation
            return {
                from: {
                    X1: fromX1,
                    Y1: fromY1,
                    X2: fromX2,
                    Y2: fromY2,
                },
                to: {
                    X: toX,
                    Y: toY
                },
                fillStyle: fillStyle,
                lineWidth: lineWidth,
                alpha: alpha
            };
        }
        function drawOuterMetallicArc(options) {
            /* Draw the metallic border of the speedometer
            * Outer grey area
            */
            options.ctx.beginPath();

            // Nice shade of grey
            options.ctx.strokeStyle = options.lineColor;

            // Draw the outer circle
            options.ctx.arc(options.center.X,
                options.center.Y,
                options.radius,
                Math.PI + (Math.PI / 180 * -30),
                0 - (Math.PI / 180 * -30),
                false);

            // Fill the last object
            options.ctx.stroke();
            // options.ctx.beginPath();

            // options.ctx.globalAlpha = alphaValue;
            // options.ctx.lineWidth = 5;
            // options.ctx.strokeStyle = strokeStyle;

            // options.ctx.arc(options.center.X,
            //     options.center.Y,
            //     options.levelRadius,
            //     Math.PI + (Math.PI / 180 * startPos),
            //     0 - (Math.PI / 180 * startPos),
            //     false);

            // options.ctx.stroke();
            
        }

        function drawInnerMetallicArc(options) {
            /* Draw the metallic border of the speedometer
            * Inner white area
            */

            options.ctx.beginPath();

            // White
            options.ctx.fillStyle = options.lineColor;
            options.ctx.strokeStyle = options.lineColor;
            options.ctx.lineWidth = 5;

            // Outer circle (subtle edge in the grey)
            options.ctx.arc(options.center.X,
                options.center.Y,
                (options.radius * .8),
                Math.PI + (Math.PI / 180 * -30),
                Math.PI + (Math.PI / 180 * (180 + 30)),
                false);

            options.ctx.stroke();

            
        }

        function drawMetallicArc(options) {
            /* Draw the metallic border of the speedometer
            * by drawing two semi-circles, one over lapping
            * the other with a bot of alpha transparency
            */

            //drawOuterMetallicArc(options);
            drawInnerMetallicArc(options);
        }

        function drawBackground(options) {
            /* Black background with alphs transparency to
            * blend the edges of the metallic edge and
            * black background
            */
            var i = 0;

            options.ctx.globalAlpha = 0.2;
            options.ctx.fillStyle = "rgb(0,0,0)";

            // Draw semi-transparent circles
            for (i = options.gaugeOptions.radius-30; i < options.gaugeOptions.radius+10; i++) {
                options.ctx.beginPath();

                options.ctx.arc(options.center.X,
                    options.center.Y,
                    i,
                    Math.PI + (Math.PI / 180 * -30),
                    0 - (Math.PI / 180 * -30),
                    false);

                options.ctx.fill();
            }

        }

        function applyDefaultContextSettings(options) {
            /* Helper function to revert to gauges
            * default settings
            */

            options.ctx.lineWidth = 2;
            options.ctx.globalAlpha = 1;
            options.ctx.strokeStyle = options.lineColor;
            options.ctx.fillStyle = options.lineColor;
        }

        function drawSmallTickMarks(options) {
            /* The small tick marks against the coloured
            * arc drawn every 5 mph from 10 degrees to
            * 170 degrees.
            */

            var tickvalue = options.levelRadius - 8,
            iTick = 0,
            gaugeOptions = options.gaugeOptions,
            iTickRad = 0,
            onArchX,
            onArchY,
            innerTickX,
            innerTickY,
            fromX,
            fromY,
            line,
            toX,
            toY;

            applyDefaultContextSettings(options);

            // Tick every 20 degrees (small ticks)
            for (iTick = -30; iTick < 220; iTick += 20) {

                iTickRad = degToRad(iTick);

                /* Calculate the X and Y of both ends of the
                * line I need to draw at angle represented at Tick.
                * The aim is to draw the a line starting on the
                * coloured arc and continueing towards the outer edge
                * in the direction from the center of the gauge.
                */

                onArchX = gaugeOptions.radius - (Math.cos(iTickRad) * tickvalue);
                onArchY = gaugeOptions.radius - (Math.sin(iTickRad) * tickvalue);
                innerTickX = gaugeOptions.radius - (Math.cos(iTickRad) * gaugeOptions.radius);
                innerTickY = gaugeOptions.radius - (Math.sin(iTickRad) * gaugeOptions.radius);

                fromX = (options.center.X - gaugeOptions.radius) + onArchX;
                fromY = (gaugeOptions.center.Y - gaugeOptions.radius) + onArchY;
                toX = (options.center.X - gaugeOptions.radius) + innerTickX;
                toY = (gaugeOptions.center.Y - gaugeOptions.radius) + innerTickY;

                // Create a line expressed in JSON
                line = createLine(fromX, fromY, toX, toY, "rgb(127,127,127)", 3, 0.6);

                // Draw the line
                drawLine(options, line);

            }
        }

        function drawLargeTickMarks(options) {
            /* The large tick marks against the coloured
            * arc drawn every 10 mph from 10 degrees to
            * 170 degrees.
            */

            var tickvalue = options.levelRadius - 8,
            iTick = 0,
            gaugeOptions = options.gaugeOptions,
            iTickRad = 0,
            innerTickY,
            innerTickX,
            onArchX,
            onArchY,
            fromX,
            fromY,
            toX,
            toY,
            line;

            applyDefaultContextSettings(options);

            tickvalue = options.levelRadius - 2;

            // 10 units (major ticks)
            for (iTick = -20; iTick < 220; iTick += 20) {

                iTickRad = degToRad(iTick);

                /* Calculate the X and Y of both ends of the
                * line I need to draw at angle represented at Tick.
                * The aim is to draw the a line starting on the
                * coloured arc and continueing towards the outer edge
                * in the direction from the center of the gauge.
                */

                onArchX = gaugeOptions.radius - (Math.cos(iTickRad) * tickvalue);
                onArchY = gaugeOptions.radius - (Math.sin(iTickRad) * tickvalue);
                innerTickX = gaugeOptions.radius - (Math.cos(iTickRad) * gaugeOptions.radius);
                innerTickY = gaugeOptions.radius - (Math.sin(iTickRad) * gaugeOptions.radius);

                fromX = (options.center.X - gaugeOptions.radius) + onArchX;
                fromY = (gaugeOptions.center.Y - gaugeOptions.radius) + onArchY;
                toX = (options.center.X - gaugeOptions.radius) + innerTickX;
                toY = (gaugeOptions.center.Y - gaugeOptions.radius) + innerTickY;

                // Create a line expressed in JSON
                line = createLine(fromX, fromY, toX, toY, "rgb(127,127,127)", 3, 0.6);

                // Draw the line
                drawLine(options, line);
            }
        }

        function drawTicks(options) {
            /* Two tick in the coloured arc!
            * Small ticks every 5
            * Large ticks every 10
            */
            drawSmallTickMarks(options);
            drawLargeTickMarks(options);
        }

        function drawTextMarkers(options) {
            /* The text labels marks above the coloured
            * arc drawn every 10 mph from 10 degrees to
            * 170 degrees.
            */
            var innerTickX = 0,
            innerTickY = 0,
            iTick = 0,
            gaugeOptions = options.gaugeOptions,
            iTickToPrint = 00;

            applyDefaultContextSettings(options);

            // Font styling
            options.ctx.font = 'italic 15px sans-serif';
            options.ctx.textBaseline = 'top';

            options.ctx.beginPath();

            // Tick every 20 (small ticks)
            for (iTick = -30; iTick < 220; iTick += 40) {

                innerTickX = gaugeOptions.radius - (Math.cos(degToRad(iTick)) * gaugeOptions.radius*.6);
                innerTickY = gaugeOptions.radius - (Math.sin(degToRad(iTick)) * gaugeOptions.radius*.6);

                // Some cludging to center the values (TODO: Improve)
                if (iTick <= 10) {
                    options.ctx.fillText(iTickToPrint, (options.center.X - gaugeOptions.radius - 12) + innerTickX,
                        (gaugeOptions.center.Y - gaugeOptions.radius - 12) + innerTickY + 5);
                } else if (iTick < 50) {
                    options.ctx.fillText(iTickToPrint, (options.center.X - gaugeOptions.radius - 12) + innerTickX - 5,
                        (gaugeOptions.center.Y - gaugeOptions.radius - 12) + innerTickY + 5);
                } else if (iTick < 90) {
                    options.ctx.fillText(iTickToPrint, (options.center.X - gaugeOptions.radius - 12) + innerTickX,
                        (gaugeOptions.center.Y - gaugeOptions.radius - 12) + innerTickY);
                } else if (iTick === 90) {
                    options.ctx.fillText(iTickToPrint, (options.center.X - gaugeOptions.radius - 12) + innerTickX + 4,
                        (gaugeOptions.center.Y - gaugeOptions.radius - 12) + innerTickY);
                } else if (iTick < 145) {
                    options.ctx.fillText(iTickToPrint, (options.center.X - gaugeOptions.radius - 12) + innerTickX + 10,
                        (gaugeOptions.center.Y - gaugeOptions.radius - 12) + innerTickY);
                } else {
                    options.ctx.fillText(iTickToPrint, (options.center.X - gaugeOptions.radius - 12) + innerTickX + 15,
                        (gaugeOptions.center.Y - gaugeOptions.radius - 12) + innerTickY + 5);
                }

                // MPH increase by 10 every 20 degrees
                //iTickToPrint += Math.round(2160 / 9);
                iTickToPrint += 5;
            }

            options.ctx.stroke();
        }

        function drawSpeedometerPart(options, alphaValue, strokeStyle, startPos, endPos, lineWidth) {
            /* Draw part of the arc that represents
            * the colour speedometer arc
            */

            options.ctx.beginPath();

            options.ctx.globalAlpha = alphaValue;
            options.ctx.lineWidth = lineWidth;
            options.ctx.strokeStyle = strokeStyle;

            options.ctx.arc(options.center.X,
                options.center.Y,
                options.levelRadius - 20,
                Math.PI + (Math.PI / 180 * startPos),
                Math.PI + (Math.PI / 180 * endPos),
                false);

            options.ctx.stroke();
        }

        function drawSpeedometerColourArc(options) {
            /* Draws the colour arc.  Three different colours
            * used here; thus, same arc drawn 3 times with
            * different colours.
            * TODO: Gradient possible?
            */

            var startOfGreen = -30,
            endOfGreen = 90+30,
            endOfOrange = 90+80,
            end = 180-startOfGreen;
            lineWidth = 10;

            drawSpeedometerPart(options, 1.0, "#008000", startOfGreen, end, lineWidth);
            drawSpeedometerPart(options, 0.9, "#FFFF00", endOfGreen, end, lineWidth);
            drawSpeedometerPart(options, 0.9, "#FF0000", endOfOrange, end, lineWidth);

        }

        function drawNeedleDial(options, alphaValue, strokeStyle, fillStyle) {
            /* Draws the metallic dial that covers the base of the
            * needle.
            */
            var i = 0;

            options.ctx.globalAlpha = alphaValue;
            options.ctx.lineWidth = 3;
            options.ctx.strokeStyle = strokeStyle;
            options.ctx.fillStyle = fillStyle;

            // Draw several transparent circles with alpha
            for (i = 0; i < 10; i++) {

                options.ctx.beginPath();
                options.ctx.arc(options.center.X,
                    options.center.Y,
                    i,
                    0,
                    2*Math.PI,
                    true);

                options.ctx.fill();
                options.ctx.stroke();
            }
        }

        function convertSpeedToAngle(options) {
            /* Helper function to convert a speed to the
            * equivelant angle.
            */
            var iSpeed = (options.speed / 10),
            iSpeedAsAngle = ((iSpeed * 20) + 10) % 180;

            // Ensure the angle is within range
            if (iSpeedAsAngle > 180) {
                iSpeedAsAngle = iSpeedAsAngle - 180;
            } else if (iSpeedAsAngle < 0) {
                iSpeedAsAngle = iSpeedAsAngle + 180;
            }

            return iSpeedAsAngle;
        }

        function drawNeedle(options) {
            /* Draw the needle in a nice read colour at the
            * angle that represents the options.speed value.
            */

            var iSpeedAsAngle = convertSpeedToAngle(options),
            iSpeedAsAngleRad = degToRad(iSpeedAsAngle),
            gaugeOptions = options.gaugeOptions,
            triangleBasePosXOffset = Math.sin(iSpeedAsAngleRad) * 3,
            triangleBasePosYOffset = Math.cos(iSpeedAsAngleRad) * -3,
            triangleBaseNegXOffset = Math.sin(iSpeedAsAngleRad) * -3,
            triangleBaseNegYOffset = Math.cos(iSpeedAsAngleRad) * 3,
            fromX1 = gaugeOptions.center.X + triangleBasePosXOffset,
            fromY1 = gaugeOptions.center.Y + triangleBasePosYOffset,
            fromX2 = gaugeOptions.center.X + triangleBaseNegXOffset,
            fromY2 = gaugeOptions.center.Y + triangleBaseNegYOffset,
            endNeedleX = gaugeOptions.radius - (Math.cos(iSpeedAsAngleRad) * gaugeOptions.radius),
            endNeedleY = gaugeOptions.radius - (Math.sin(iSpeedAsAngleRad) * gaugeOptions.radius),
            toX = (gaugeOptions.center.X - gaugeOptions.radius) + endNeedleX,
            toY = (gaugeOptions.center.Y - gaugeOptions.radius) + endNeedleY,
            triangle = createTriangle(fromX1, fromY1, fromX2, fromY2, toX, toY, "#FFFFF", 5, 1.0);

            drawTriangle(options, triangle);

            // Two circle to draw the dial at the base (give its a nice effect?)
            drawNeedleDial(options, 0.6, "#FFFFF", options.lineColor);
            drawNeedleDial(options, 0.2, "#FFFFF", "#FFFFF");

        }

        function buildOptionsAsJSON(canvas, iSpeed) {
            /* Setting for the speedometer
            * Alter these to modify its look and feel
            */
            //canvas.width = 10000;
            //canvas.height = 10000;

            radius = 200,
            outerRadius = 300;

            // Create a speedometer object using Javascript object notation
            return {
                ctx: canvas.getContext('2d'),
                speed: iSpeed,
                center: {
                    X: canvas.width/2,
                    Y: canvas.height/2
                },
                levelRadius: radius - 10,
                gaugeOptions: {
                    center: {
                        X: canvas.width/2,
                        Y: canvas.height/2
                    },
                    radius: radius
                },
                radius: outerRadius,
                lineColor: "#FFFFFF",
                textColor: "#FFFFFF"
            };
        }

        function clearCanvas(options) {
            options.ctx.clearRect(0, 0, 800, 600);
            applyDefaultContextSettings(options);
        }

        function draw() {
            /* Main entry point for drawing the speedometer
            * If canvas is not support alert the user.
            */

            console.log('Target: ' + iTargetSpeed);
            console.log('Current: ' + iCurrentSpeed);

            var canvas = document.getElementById('speedometer');
          // Make it visually fill the positioned parent
          // canvas.style.width ='100%';
          // canvas.style.height=canvas.style.width;
          // ...then set the internal size to match
          // canvas.width  = canvas.offsetWidth;
          // canvas.height = canvas.offsetHeight;
            canvas.width = screen.availWidth;
            canvas.height = screen.availHeight;

            options = null;

            // Canvas good?
            if (canvas !== null && canvas.getContext) {
                options = buildOptionsAsJSON(canvas, iCurrentSpeed);

                // Clear canvas
                clearCanvas(options);

                // Draw the metallic styled edge
                drawMetallicArc(options);

                // Draw thw background
                drawBackground(options);

                // Draw tick marks
                drawTicks(options);

                // Draw labels on markers
                drawTextMarkers(options);

                // Draw speeometer colour arc
                drawSpeedometerColourArc(options);

                // Draw the needle and base
                drawNeedle(options);

            } else {
                alert("Canvas not supported by your browser!");
            }

            if (iTargetSpeed == iCurrentSpeed) {
                clearTimeout(job);
                return;
            } else if (iTargetSpeed < iCurrentSpeed) {
                bDecrement = true;
            } else if (iTargetSpeed > iCurrentSpeed) {
                bDecrement = false;
            }

            if (bDecrement) {
                if (iCurrentSpeed - 10 < iTargetSpeed)
                    iCurrentSpeed = iCurrentSpeed - 1;
                else
                    iCurrentSpeed = iCurrentSpeed - 5;
            } else {

                if (iCurrentSpeed + 10 > iTargetSpeed)
                    iCurrentSpeed = iCurrentSpeed + 1;
                else
                    iCurrentSpeed = iCurrentSpeed + 5;
            }

            job = setTimeout("draw()", 5);
        }

        function drawWithInputValue() {

            var txtSpeed = document.getElementById('txtSpeed');

            if (txtSpeed !== null) {

                iTargetSpeed = txtSpeed.value;

                // Sanity checks
                if (isNaN(iTargetSpeed)) {
                    iTargetSpeed = 0;
                }
                // else if (iTargetSpeed < 0) {
                //     iTargetSpeed = 0;
                // }
                // else if (iTargetSpeed > 80) {
                //     iTargetSpeed = 80;
                // }

                job = setTimeout("draw()", 5);

            }
        }

function resize() {
    draw();
}
window.addEventListener('resize', resize, false); resize();

</script>
</head>
<body onload='draw(0);' style="background-color:#000000">
    <canvas id="speedometer" width="500" height="500">Canvas not available.</canvas>
    <div>
        <form id="drawTemp">
            <input type="text" id="txtSpeed" name="txtSpeed" value="0" maxlength="3" />
            <input type="button" value="Draw" onclick="drawWithInputValue();">
        </form>
    </div>
</body>
</html>